{% extends "base.html" %}

{% block styles %}
<link rel="stylesheet" href="{{ url_for('static', filename='check_in.css') }}">
{% endblock %}

{% block content %}
<div class="chat-wrapper">
    <div class="chat-container">
        <div id="messages" class="messages">
            <p id="no-messages" style="font-size: 24pt; text-align: center; color: #999;">
                Press the start check in button below to start the check in process
            </p>
        </div>
        <div class="chat-controls">
            <button id="start-check-in-button">Start Check-In</button>
            <br>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // Handle "Start Check-In" button click
    document.getElementById('start-check-in-button').addEventListener('click', function () {
        fetch('/start_check_in', { method: 'POST' })
            .then((response) => response.json())
            .then((data) => {
                // Remove the place holder message
                const noMessages = document.getElementById('no-messages');
                if (noMessages) noMessages.remove();
                // Remove the chat controls
                const chatControls = document.querySelector('.chat-controls');
                if (chatControls) chatControls.remove();                

                // Add the progress bar
                const chatContainer = document.querySelector('.chat-container');

                const progressBar = document.createElement('div');
                progressBar.id = 'myProgress';
                progressBar.innerHTML = `
                    <div id="myBar"></div>
                `;
                chatContainer.appendChild(progressBar);
            })
            .catch((error) => console.error('Error starting check-in:', error));
    });

    window.socket.on('connect', function () {
        console.log("Connected to Socket.IO server");
    });

    // Listen for check-in completion
    window.socket.on('check_in_complete', function () {
        console.log("Check-in complete event received");
        const progressBar = document.getElementById('myProgress');
        if (progressBar) progressBar.remove();

        const chatContainer = document.querySelector('.chat-container');

        const chatControl = document.createElement('div');
        chatControl.classList.add('chat-controls');
        chatControl.innerHTML = `
                    <button id="restart-checkin">Restart Check-In</button>
                    <button id="save-checkin">Save Check-In</button>
                `;
        chatContainer.appendChild(chatControl);
        
        document.getElementById('save-checkin').addEventListener('click', function () {
            console.log('Save Check-In button clicked');
        });

        document.getElementById('restart-checkin').addEventListener('click', function () {
            console.log('Restart Check-In button clicked');
        });
    });
    
    // TODO: Have a count down in the save checking button to let users know that their response will be saved
    // TODO: If the restart button is pressed clear the cach and send a start check in request
    




    // Listen for new messages
    window.socket.on('new_message', function(message) {
        const noMessages = document.getElementById('no-messages');
        if (noMessages) noMessages.remove(); // Remove placeholder if it exists
        if (message.sender === 'robot') {
            appendReceivedMessage(message.content, message.time);
        } else {
            appendOutgoingMessage(message.content, message.time);    
        }
    });    
    
    // Function to create and append a received message
    function appendReceivedMessage(content, time) {
        const messages = document.getElementById('messages');
        
        const receivedChat = document.createElement('div');
        receivedChat.classList.add('received-message'); // Apply received message styling
        receivedChat.innerHTML = `
            <p>${content}</p>
            <span class="time">${time}</span>
            `;    
        messages.appendChild(receivedChat);
        scrollToBottom(); // Auto-scroll to the bottom
    }    

    // Function to create and append an outgoing message
    function appendOutgoingMessage(content, time) {
        const messages = document.getElementById('messages');

        const outgoingChat = document.createElement('div');
        outgoingChat.classList.add('outgoing-message'); // Apply outgoing message styling
        outgoingChat.innerHTML = `
        <p>${content}</p>
        <span class="time">${time}</span>
        `;    
        messages.appendChild(outgoingChat);
        scrollToBottom(); // Auto-scroll to the bottom
    }    
    
    function scrollToBottom() {
        const messages = document.getElementById('messages');
        messages.scrollTop = messages.scrollHeight; // Scroll to the bottom
    }    
    
    // Load chat history on connection
    window.socket.on('chat_history', function(history) {
        history.forEach(message => {
            if (message.sender === 'robot') {
                appendReceivedMessage(message.content, message.time);
            } else {
                appendOutgoingMessage(message.content, message.time);        
            }
        });
    });    
    
    
    
        
    
    let animationId = null; // To store the current animation frame ID
    
    window.socket.on('silence_detected', function (data) {
        const duration = parseFloat(data.duration); // Get the duration in seconds
        if (isNaN(duration) || duration < 0) {
            console.error("Invalid duration received:", duration);
            return;
        }    

        const elem = document.getElementById("myBar");
        if (!elem) {
            console.error("Element #myBar not found");
            return;
        }    

        // Reset the progress bar and stop the current animation if a new request comes in
        if (animationId) {
            cancelAnimationFrame(animationId); // Stop the current animation
            animationId = null;
            elem.style.transform = `scaleX(1)`; // Reset progress bar
        }    

        if (duration === 0) {
            console.warn("User is talking, resetting progress bar immediately.");
            return; // Exit early, no animation is needed
        }    

        let startTime = Date.now(); // Record the animation start time
        const totalTime = duration * 1000; // Convert duration to milliseconds

        function frame() {
            const elapsedTime = Date.now() - startTime;
            const progress = 1 - Math.min(elapsedTime / totalTime, 1); // Calculate progress (clamp to 1)

            elem.style.transform = `scaleX(${progress})`; // Update transform to match progress

            if (progress > 0) {
                animationId = requestAnimationFrame(frame); // Continue animation
            } else {
                animationId = null; // Clear animation ID when complete
            }
        }    

        // Start the animation
        animationId = requestAnimationFrame(frame);
    });






    // document.getElementById('restart checking').addEventListener('click', function () {

    // });

    // document.getElementById('save checking').addEventListener('click', function () {

    // });




    

    // Enable click-and-drag scrolling for the messages container
    const messages = document.getElementById('messages');

    let isDragging = false;
    let startY = 0; // Initial Y position of the pointer
    let scrollTop = 0; // Initial scroll position of the container

    messages.addEventListener('mousedown', (e) => {
        isDragging = true;
        startY = e.pageY - messages.offsetTop;
        scrollTop = messages.scrollTop;
        messages.style.cursor = 'grabbing'; // Change cursor to grabbing
    });

    messages.addEventListener('mouseleave', () => {
        isDragging = false;
        messages.style.cursor = 'default'; // Reset cursor
    });

    messages.addEventListener('mouseup', () => {
        isDragging = false;
        messages.style.cursor = 'default'; // Reset cursor
    });

    messages.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();
        const y = e.pageY - messages.offsetTop;
        const walk = (y - startY) * 2; // Adjust scroll speed
        messages.scrollTop = scrollTop - walk;
    });

</script>
{% endblock %}
